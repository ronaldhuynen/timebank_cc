/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@yaireo/tagify/dist/tagify.polyfills.min.js":
/*!******************************************************************!*\
  !*** ./node_modules/@yaireo/tagify/dist/tagify.polyfills.min.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Tagify (v 4.17.8) - tags input component\n * By undefined\n * https://github.com/yairEO/tagify\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n * \r\n * THE SOFTWARE IS NOT PERMISSIBLE TO BE SOLD.\n */\n\n(function (factory) {\n   true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) :\n  0;\n})((function () { 'use strict';\n\n  // 1. String.prototype.trim polyfill\n  if (!\"\".trim) String.prototype.trim = function () {\n    return this.replace(/^[\\s﻿]+|[\\s﻿]+$/g, '');\n  };\n\n  if (window.NodeList && !NodeList.prototype.forEach) {\n    NodeList.prototype.forEach = Array.prototype.forEach;\n  }\n\n  if (!Array.prototype.findIndex) {\n    Object.defineProperty(Array.prototype, 'findIndex', {\n      value: function (predicate) {\n        if (this == null) throw new TypeError('\"this\" is null or not defined');\n        var o = Object(this),\n          len = o.length >>> 0;\n        if (typeof predicate !== 'function') {\n          throw new TypeError('predicate must be a function');\n        }\n        var thisArg = arguments[1],\n          k = 0;\n        while (k < len) {\n          var kValue = o[k];\n          if (predicate.call(thisArg, kValue, k, o)) {\n            return k;\n          }\n          k++;\n        }\n        return -1;\n      },\n      configurable: true,\n      writable: true\n    });\n  }\n\n  if (!Array.prototype.includes) {\n    Array.prototype.includes = function (search) {\n      return !!~this.indexOf(search);\n    };\n  }\n\n  // Production steps of ECMA-262, Edition 5, 15.4.4.17\n  // Reference: http://es5.github.io/#x15.4.4.17\n  if (!Array.prototype.some) {\n    Array.prototype.some = function (fun, thisArg) {\n\n      if (this == null) {\n        throw new TypeError('Array.prototype.some called on null or undefined');\n      }\n      if (typeof fun !== 'function') {\n        throw new TypeError();\n      }\n      var t = Object(this);\n      var len = t.length >>> 0;\n      for (var i = 0; i < len; i++) {\n        if (i in t && fun.call(thisArg, t[i], i, t)) {\n          return true;\n        }\n      }\n      return false;\n    };\n  }\n\n  if (!String.prototype.includes) {\n    String.prototype.includes = function (search, start) {\n      if (typeof start !== 'number') start = 0;\n      if (start + search.length > this.length) return false;else return this.indexOf(search, start) !== -1;\n    };\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill\n  //\n  if (typeof Object.assign != 'function') {\n    // Must be writable: true, enumerable: false, configurable: true\n    Object.defineProperty(Object, \"assign\", {\n      value: function assign(target, varArgs) {\n        // .length of function is 2\n        if (target == null) {\n          // TypeError if undefined or null\n          throw new TypeError('Cannot convert undefined or null to object');\n        }\n        var to = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n          var nextSource = arguments[index];\n          if (nextSource != null) {\n            // Skip over if undefined or null\n            for (var nextKey in nextSource) {\n              // Avoid bugs when hasOwnProperty is shadowed\n              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                to[nextKey] = nextSource[nextKey];\n              }\n            }\n          }\n        }\n        return to;\n      },\n      writable: true,\n      configurable: true\n    });\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n  function CustomEventPolyfill(event, params) {\n    params = params || {\n      bubbles: false,\n      cancelable: false,\n      detail: undefined\n    };\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  }\n  CustomEventPolyfill.prototype = window.Event.prototype;\n  if (typeof window.CustomEvent !== \"function\") {\n    window.CustomEvent = CustomEventPolyfill;\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n  if (!Element.prototype.matches) Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\n  if (!Element.prototype.closest) {\n    Element.prototype.closest = function (s) {\n      var el = this;\n      if (!document.documentElement.contains(el)) return null;\n      do {\n        if (el.matches(s)) return el;\n        el = el.parentElement || el.parentNode;\n      } while (el !== null && el.nodeType === 1);\n      return null;\n    };\n  }\n\n  // Avoid transformation text to link ie contentEditable mode\n  // https://stackoverflow.com/q/7556007/104380\n  document.execCommand(\"AutoUrlDetect\", false, false);\n\n  /*\r\n   * classList.js: Cross-browser full element.classList implementation.\r\n   * 1.2.20171210\r\n   *\r\n   * By Eli Grey, http://eligrey.com\r\n   * License: Dedicated to the public domain.\r\n   *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md\r\n   */\n\n  /*global self, document, DOMException */\n\n  /*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */\n\n  if (\"document\" in self) {\n    // Full polyfill for browsers with no classList support\n    // Including IE < Edge missing SVGElement.classList\n    if (!(\"classList\" in document.createElement(\"_\")) || document.createElementNS && !(\"classList\" in document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"))) {\n      (function (view) {\n\n        if (!('Element' in view)) return;\n        var classListProp = \"classList\",\n          protoProp = \"prototype\",\n          elemCtrProto = view.Element[protoProp],\n          objCtr = Object,\n          strTrim = String[protoProp].trim || function () {\n            return this.replace(/^\\s+|\\s+$/g, \"\");\n          },\n          arrIndexOf = Array[protoProp].indexOf || function (item) {\n            var i = 0,\n              len = this.length;\n            for (; i < len; i++) {\n              if (i in this && this[i] === item) {\n                return i;\n              }\n            }\n            return -1;\n          }\n          // Vendors: please allow content code to instantiate DOMExceptions\n          ,\n          DOMEx = function (type, message) {\n            this.name = type;\n            this.code = DOMException[type];\n            this.message = message;\n          },\n          checkTokenAndGetIndex = function (classList, token) {\n            if (token === \"\") {\n              throw new DOMEx(\"SYNTAX_ERR\", \"The token must not be empty.\");\n            }\n            if (/\\s/.test(token)) {\n              throw new DOMEx(\"INVALID_CHARACTER_ERR\", \"The token must not contain space characters.\");\n            }\n            return arrIndexOf.call(classList, token);\n          },\n          ClassList = function (elem) {\n            var trimmedClasses = strTrim.call(elem.getAttribute(\"class\") || \"\"),\n              classes = trimmedClasses ? trimmedClasses.split(/\\s+/) : [],\n              i = 0,\n              len = classes.length;\n            for (; i < len; i++) {\n              this.push(classes[i]);\n            }\n            this._updateClassName = function () {\n              elem.setAttribute(\"class\", this.toString());\n            };\n          },\n          classListProto = ClassList[protoProp] = [],\n          classListGetter = function () {\n            return new ClassList(this);\n          };\n        // Most DOMException implementations don't allow calling DOMException's toString()\n        // on non-DOMExceptions. Error's toString() is sufficient here.\n        DOMEx[protoProp] = Error[protoProp];\n        classListProto.item = function (i) {\n          return this[i] || null;\n        };\n        classListProto.contains = function (token) {\n          return ~checkTokenAndGetIndex(this, token + \"\");\n        };\n        classListProto.add = function () {\n          var tokens = arguments,\n            i = 0,\n            l = tokens.length,\n            token,\n            updated = false;\n          do {\n            token = tokens[i] + \"\";\n            if (!~checkTokenAndGetIndex(this, token)) {\n              this.push(token);\n              updated = true;\n            }\n          } while (++i < l);\n          if (updated) {\n            this._updateClassName();\n          }\n        };\n        classListProto.remove = function () {\n          var tokens = arguments,\n            i = 0,\n            l = tokens.length,\n            token,\n            updated = false,\n            index;\n          do {\n            token = tokens[i] + \"\";\n            index = checkTokenAndGetIndex(this, token);\n            while (~index) {\n              this.splice(index, 1);\n              updated = true;\n              index = checkTokenAndGetIndex(this, token);\n            }\n          } while (++i < l);\n          if (updated) {\n            this._updateClassName();\n          }\n        };\n        classListProto.toggle = function (token, force) {\n          var result = this.contains(token),\n            method = result ? force !== true && \"remove\" : force !== false && \"add\";\n          if (method) {\n            this[method](token);\n          }\n          if (force === true || force === false) {\n            return force;\n          } else {\n            return !result;\n          }\n        };\n        classListProto.replace = function (token, replacement_token) {\n          var index = checkTokenAndGetIndex(token + \"\");\n          if (~index) {\n            this.splice(index, 1, replacement_token);\n            this._updateClassName();\n          }\n        };\n        classListProto.toString = function () {\n          return this.join(\" \");\n        };\n        if (objCtr.defineProperty) {\n          var classListPropDesc = {\n            get: classListGetter,\n            enumerable: true,\n            configurable: true\n          };\n          try {\n            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n          } catch (ex) {\n            // IE 8 doesn't support enumerable:true\n            // adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36\n            // modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected\n            if (ex.number === undefined || ex.number === -0x7FF5EC54) {\n              classListPropDesc.enumerable = false;\n              objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n            }\n          }\n        } else if (objCtr[protoProp].__defineGetter__) {\n          elemCtrProto.__defineGetter__(classListProp, classListGetter);\n        }\n      })(self);\n    }\n\n    // There is full or partial native classList support, so just check if we need\n    // to normalize the add/remove and toggle APIs.\n\n    (function () {\n\n      var testElement = document.createElement(\"_\");\n      testElement.classList.add(\"c1\", \"c2\");\n\n      // Polyfill for IE 10/11 and Firefox <26, where classList.add and\n      // classList.remove exist but support only one argument at a time.\n      if (!testElement.classList.contains(\"c2\")) {\n        var createMethod = function (method) {\n          var original = DOMTokenList.prototype[method];\n          DOMTokenList.prototype[method] = function (token) {\n            var i,\n              len = arguments.length;\n            for (i = 0; i < len; i++) {\n              token = arguments[i];\n              original.call(this, token);\n            }\n          };\n        };\n        createMethod('add');\n        createMethod('remove');\n      }\n      testElement.classList.toggle(\"c3\", false);\n\n      // Polyfill for IE 10 and Firefox <24, where classList.toggle does not\n      // support the second argument.\n      if (testElement.classList.contains(\"c3\")) {\n        var _toggle = DOMTokenList.prototype.toggle;\n        DOMTokenList.prototype.toggle = function (token, force) {\n          if (1 in arguments && !this.contains(token) === !force) {\n            return force;\n          } else {\n            return _toggle.call(this, token);\n          }\n        };\n      }\n\n      // replace() polyfill\n      if (!(\"replace\" in document.createElement(\"_\").classList)) {\n        DOMTokenList.prototype.replace = function (token, replacement_token) {\n          var tokens = this.toString().split(\" \"),\n            index = tokens.indexOf(token + \"\");\n          if (~index) {\n            tokens = tokens.slice(index);\n            this.remove.apply(this, tokens);\n            this.add(replacement_token);\n            this.add.apply(this, tokens.slice(1));\n          }\n        };\n      }\n      testElement = null;\n    })();\n  }\n\n  // https://github.com/taylorhakes/promise-polyfill\n\n  (function (global, factory) {\n     true ? factory() : 0;\n  })(undefined, function () {\n\n    /**\r\n    * @this {Promise}\r\n    */\n    function finallyConstructor(callback) {\n      var constructor = this.constructor;\n      return this.then(function (value) {\n        // @ts-ignore\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        // @ts-ignore\n        return constructor.resolve(callback()).then(function () {\n          // @ts-ignore\n          return constructor.reject(reason);\n        });\n      });\n    }\n    function allSettled(arr) {\n      var P = this;\n      return new P(function (resolve, reject) {\n        if (!(arr && typeof arr.length !== 'undefined')) {\n          return reject(new TypeError(typeof arr + ' ' + arr + ' is not iterable(cannot read property Symbol(Symbol.iterator))'));\n        }\n        var args = Array.prototype.slice.call(arr);\n        if (args.length === 0) return resolve([]);\n        var remaining = args.length;\n        function res(i, val) {\n          if (val && (typeof val === 'object' || typeof val === 'function')) {\n            var then = val.then;\n            if (typeof then === 'function') {\n              then.call(val, function (val) {\n                res(i, val);\n              }, function (e) {\n                args[i] = {\n                  status: 'rejected',\n                  reason: e\n                };\n                if (--remaining === 0) {\n                  resolve(args);\n                }\n              });\n              return;\n            }\n          }\n          args[i] = {\n            status: 'fulfilled',\n            value: val\n          };\n          if (--remaining === 0) {\n            resolve(args);\n          }\n        }\n        for (var i = 0; i < args.length; i++) {\n          res(i, args[i]);\n        }\n      });\n    }\n\n    // Store setTimeout reference so promise-polyfill will be unaffected by\n    // other code modifying setTimeout (like sinon.useFakeTimers())\n    var setTimeoutFunc = setTimeout;\n    function isArray(x) {\n      return Boolean(x && typeof x.length !== 'undefined');\n    }\n    function noop() {}\n\n    // Polyfill for Function.prototype.bind\n    function bind(fn, thisArg) {\n      return function () {\n        fn.apply(thisArg, arguments);\n      };\n    }\n\n    /**\r\n    * @constructor\r\n    * @param {Function} fn\r\n    */\n    function Promise(fn) {\n      if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');\n      if (typeof fn !== 'function') throw new TypeError('not a function');\n      /** @type {!number} */\n      this._state = 0;\n      /** @type {!boolean} */\n      this._handled = false;\n      /** @type {Promise|undefined} */\n      this._value = undefined;\n      /** @type {!Array<!Function>} */\n      this._deferreds = [];\n      doResolve(fn, this);\n    }\n    function handle(self, deferred) {\n      while (self._state === 3) {\n        self = self._value;\n      }\n      if (self._state === 0) {\n        self._deferreds.push(deferred);\n        return;\n      }\n      self._handled = true;\n      Promise._immediateFn(function () {\n        var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n        if (cb === null) {\n          (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n          return;\n        }\n        var ret;\n        try {\n          ret = cb(self._value);\n        } catch (e) {\n          reject(deferred.promise, e);\n          return;\n        }\n        resolve(deferred.promise, ret);\n      });\n    }\n    function resolve(self, newValue) {\n      try {\n        // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n        if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n        if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n          var then = newValue.then;\n          if (newValue instanceof Promise) {\n            self._state = 3;\n            self._value = newValue;\n            finale(self);\n            return;\n          } else if (typeof then === 'function') {\n            doResolve(bind(then, newValue), self);\n            return;\n          }\n        }\n        self._state = 1;\n        self._value = newValue;\n        finale(self);\n      } catch (e) {\n        reject(self, e);\n      }\n    }\n    function reject(self, newValue) {\n      self._state = 2;\n      self._value = newValue;\n      finale(self);\n    }\n    function finale(self) {\n      if (self._state === 2 && self._deferreds.length === 0) {\n        Promise._immediateFn(function () {\n          if (!self._handled) {\n            Promise._unhandledRejectionFn(self._value);\n          }\n        });\n      }\n      for (var i = 0, len = self._deferreds.length; i < len; i++) {\n        handle(self, self._deferreds[i]);\n      }\n      self._deferreds = null;\n    }\n\n    /**\r\n    * @constructor\r\n    */\n    function Handler(onFulfilled, onRejected, promise) {\n      this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n      this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n      this.promise = promise;\n    }\n\n    /**\r\n    * Take a potentially misbehaving resolver function and make sure\r\n    * onFulfilled and onRejected are only called once.\r\n    *\r\n    * Makes no guarantees about asynchrony.\r\n    */\n    function doResolve(fn, self) {\n      var done = false;\n      try {\n        fn(function (value) {\n          if (done) return;\n          done = true;\n          resolve(self, value);\n        }, function (reason) {\n          if (done) return;\n          done = true;\n          reject(self, reason);\n        });\n      } catch (ex) {\n        if (done) return;\n        done = true;\n        reject(self, ex);\n      }\n    }\n    Promise.prototype['catch'] = function (onRejected) {\n      return this.then(null, onRejected);\n    };\n    Promise.prototype.then = function (onFulfilled, onRejected) {\n      // @ts-ignore\n      var prom = new this.constructor(noop);\n      handle(this, new Handler(onFulfilled, onRejected, prom));\n      return prom;\n    };\n    Promise.prototype['finally'] = finallyConstructor;\n    Promise.all = function (arr) {\n      return new Promise(function (resolve, reject) {\n        if (!isArray(arr)) {\n          return reject(new TypeError('Promise.all accepts an array'));\n        }\n        var args = Array.prototype.slice.call(arr);\n        if (args.length === 0) return resolve([]);\n        var remaining = args.length;\n        function res(i, val) {\n          try {\n            if (val && (typeof val === 'object' || typeof val === 'function')) {\n              var then = val.then;\n              if (typeof then === 'function') {\n                then.call(val, function (val) {\n                  res(i, val);\n                }, reject);\n                return;\n              }\n            }\n            args[i] = val;\n            if (--remaining === 0) {\n              resolve(args);\n            }\n          } catch (ex) {\n            reject(ex);\n          }\n        }\n        for (var i = 0; i < args.length; i++) {\n          res(i, args[i]);\n        }\n      });\n    };\n    Promise.allSettled = allSettled;\n    Promise.resolve = function (value) {\n      if (value && typeof value === 'object' && value.constructor === Promise) {\n        return value;\n      }\n      return new Promise(function (resolve) {\n        resolve(value);\n      });\n    };\n    Promise.reject = function (value) {\n      return new Promise(function (resolve, reject) {\n        reject(value);\n      });\n    };\n    Promise.race = function (arr) {\n      return new Promise(function (resolve, reject) {\n        if (!isArray(arr)) {\n          return reject(new TypeError('Promise.race accepts an array'));\n        }\n        for (var i = 0, len = arr.length; i < len; i++) {\n          Promise.resolve(arr[i]).then(resolve, reject);\n        }\n      });\n    };\n\n    // Use polyfill for setImmediate for performance gains\n    Promise._immediateFn =\n    // @ts-ignore\n    typeof setImmediate === 'function' && function (fn) {\n      // @ts-ignore\n      setImmediate(fn);\n    } || function (fn) {\n      setTimeoutFunc(fn, 0);\n    };\n    Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n      if (typeof console !== 'undefined' && console) {\n        console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n      }\n    };\n\n    /** @suppress {undefinedVars} */\n    var globalNS = function () {\n      // the only reliable means to get the global object is\n      // `Function('return this')()`\n      // However, this causes CSP violations in Chrome apps.\n      if (typeof self !== 'undefined') {\n        return self;\n      }\n      if (typeof window !== 'undefined') {\n        return window;\n      }\n      if (typeof __webpack_require__.g !== 'undefined') {\n        return __webpack_require__.g;\n      }\n      throw new Error('unable to locate global object');\n    }();\n\n    // Expose the polyfill if Promise is undefined or set to a\n    // non-function value. The latter can be due to a named HTMLElement\n    // being exposed by browsers for legacy reasons.\n    // https://github.com/taylorhakes/promise-polyfill/issues/114\n    if (typeof globalNS['Promise'] !== 'function') {\n      globalNS['Promise'] = Promise;\n    } else if (!globalNS.Promise.prototype['finally']) {\n      globalNS.Promise.prototype['finally'] = finallyConstructor;\n    } else if (!globalNS.Promise.allSettled) {\n      globalNS.Promise.allSettled = allSettled;\n    }\n  });\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHlhaXJlby90YWdpZnkvZGlzdC90YWdpZnkucG9seWZpbGxzLm1pbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLEtBQTBDLEdBQUcsb0NBQU8sT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0FBQzlELEVBQUUsQ0FBUztBQUNYLENBQUMsaUJBQWlCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQSxJQUFJLEtBQTRELGVBQWUsQ0FBd0U7QUFDdkosR0FBRzs7QUFFSDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBOztBQUVBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFNO0FBQ3ZCLGVBQWUscUJBQU07QUFDckI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHlhaXJlby90YWdpZnkvZGlzdC90YWdpZnkucG9seWZpbGxzLm1pbi5qcz9jMzYwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGFnaWZ5ICh2IDQuMTcuOCkgLSB0YWdzIGlucHV0IGNvbXBvbmVudFxuICogQnkgdW5kZWZpbmVkXG4gKiBodHRwczovL2dpdGh1Yi5jb20veWFpckVPL3RhZ2lmeVxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICogXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKiBcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gKiBUSEUgU09GVFdBUkUuXHJcbiAqIFxyXG4gKiBUSEUgU09GVFdBUkUgSVMgTk9UIFBFUk1JU1NJQkxFIFRPIEJFIFNPTEQuXG4gKi9cblxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIGZhY3RvcnkoKTtcbn0pKChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvLyAxLiBTdHJpbmcucHJvdG90eXBlLnRyaW0gcG9seWZpbGxcbiAgaWYgKCFcIlwiLnRyaW0pIFN0cmluZy5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9eW1xcc++7v10rfFtcXHPvu79dKyQvZywgJycpO1xuICB9O1xuXG4gIGlmICh3aW5kb3cuTm9kZUxpc3QgJiYgIU5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgTm9kZUxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbiAgfVxuXG4gIGlmICghQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsICdmaW5kSW5kZXgnLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICBpZiAodGhpcyA9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInRoaXNcIiBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgIHZhciBvID0gT2JqZWN0KHRoaXMpLFxuICAgICAgICAgIGxlbiA9IG8ubGVuZ3RoID4+PiAwO1xuICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICBrID0gMDtcbiAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICB2YXIga1ZhbHVlID0gb1trXTtcbiAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywga1ZhbHVlLCBrLCBvKSkge1xuICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gKHNlYXJjaCkge1xuICAgICAgcmV0dXJuICEhfnRoaXMuaW5kZXhPZihzZWFyY2gpO1xuICAgIH07XG4gIH1cblxuICAvLyBQcm9kdWN0aW9uIHN0ZXBzIG9mIEVDTUEtMjYyLCBFZGl0aW9uIDUsIDE1LjQuNC4xN1xuICAvLyBSZWZlcmVuY2U6IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuNC40LjE3XG4gIGlmICghQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uIChmdW4sIHRoaXNBcmcpIHtcblxuICAgICAgaWYgKHRoaXMgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuc29tZSBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZnVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXNBcmcsIHRbaV0sIGksIHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKSB7XG4gICAgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIChzZWFyY2gsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJykgc3RhcnQgPSAwO1xuICAgICAgaWYgKHN0YXJ0ICsgc2VhcmNoLmxlbmd0aCA+IHRoaXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7ZWxzZSByZXR1cm4gdGhpcy5pbmRleE9mKHNlYXJjaCwgc3RhcnQpICE9PSAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbiNQb2x5ZmlsbFxuICAvL1xuICBpZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIE11c3QgYmUgd3JpdGFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LCBcImFzc2lnblwiLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgdmFyQXJncykge1xuICAgICAgICAvLyAubGVuZ3RoIG9mIGZ1bmN0aW9uIGlzIDJcbiAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgLy8gVHlwZUVycm9yIGlmIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgIGlmIChuZXh0U291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFNraXAgb3ZlciBpZiB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBuZXh0U291cmNlKSB7XG4gICAgICAgICAgICAgIC8vIEF2b2lkIGJ1Z3Mgd2hlbiBoYXNPd25Qcm9wZXJ0eSBpcyBzaGFkb3dlZFxuICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHRTb3VyY2UsIG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0bztcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L0N1c3RvbUV2ZW50I1BvbHlmaWxsXG4gIGZ1bmN0aW9uIEN1c3RvbUV2ZW50UG9seWZpbGwoZXZlbnQsIHBhcmFtcykge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgZGV0YWlsOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgIHJldHVybiBldnQ7XG4gIH1cbiAgQ3VzdG9tRXZlbnRQb2x5ZmlsbC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgd2luZG93LkN1c3RvbUV2ZW50ID0gQ3VzdG9tRXZlbnRQb2x5ZmlsbDtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3RcbiAgaWYgKCFFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzID0gRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG4gIGlmICghRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCkge1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3QgPSBmdW5jdGlvbiAocykge1xuICAgICAgdmFyIGVsID0gdGhpcztcbiAgICAgIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGVsKSkgcmV0dXJuIG51bGw7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChlbC5tYXRjaGVzKHMpKSByZXR1cm4gZWw7XG4gICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlO1xuICAgICAgfSB3aGlsZSAoZWwgIT09IG51bGwgJiYgZWwubm9kZVR5cGUgPT09IDEpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEF2b2lkIHRyYW5zZm9ybWF0aW9uIHRleHQgdG8gbGluayBpZSBjb250ZW50RWRpdGFibGUgbW9kZVxuICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvNzU1NjAwNy8xMDQzODBcbiAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJBdXRvVXJsRGV0ZWN0XCIsIGZhbHNlLCBmYWxzZSk7XG5cbiAgLypcclxuICAgKiBjbGFzc0xpc3QuanM6IENyb3NzLWJyb3dzZXIgZnVsbCBlbGVtZW50LmNsYXNzTGlzdCBpbXBsZW1lbnRhdGlvbi5cclxuICAgKiAxLjIuMjAxNzEyMTBcclxuICAgKlxyXG4gICAqIEJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cclxuICAgKiBMaWNlbnNlOiBEZWRpY2F0ZWQgdG8gdGhlIHB1YmxpYyBkb21haW4uXHJcbiAgICogICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VsaWdyZXkvY2xhc3NMaXN0LmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcclxuICAgKi9cblxuICAvKmdsb2JhbCBzZWxmLCBkb2N1bWVudCwgRE9NRXhjZXB0aW9uICovXG5cbiAgLyohIEBzb3VyY2UgaHR0cDovL3B1cmwuZWxpZ3JleS5jb20vZ2l0aHViL2NsYXNzTGlzdC5qcy9ibG9iL21hc3Rlci9jbGFzc0xpc3QuanMgKi9cblxuICBpZiAoXCJkb2N1bWVudFwiIGluIHNlbGYpIHtcbiAgICAvLyBGdWxsIHBvbHlmaWxsIGZvciBicm93c2VycyB3aXRoIG5vIGNsYXNzTGlzdCBzdXBwb3J0XG4gICAgLy8gSW5jbHVkaW5nIElFIDwgRWRnZSBtaXNzaW5nIFNWR0VsZW1lbnQuY2xhc3NMaXN0XG4gICAgaWYgKCEoXCJjbGFzc0xpc3RcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiX1wiKSkgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmICEoXCJjbGFzc0xpc3RcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIikpKSB7XG4gICAgICAoZnVuY3Rpb24gKHZpZXcpIHtcblxuICAgICAgICBpZiAoISgnRWxlbWVudCcgaW4gdmlldykpIHJldHVybjtcbiAgICAgICAgdmFyIGNsYXNzTGlzdFByb3AgPSBcImNsYXNzTGlzdFwiLFxuICAgICAgICAgIHByb3RvUHJvcCA9IFwicHJvdG90eXBlXCIsXG4gICAgICAgICAgZWxlbUN0clByb3RvID0gdmlldy5FbGVtZW50W3Byb3RvUHJvcF0sXG4gICAgICAgICAgb2JqQ3RyID0gT2JqZWN0LFxuICAgICAgICAgIHN0clRyaW0gPSBTdHJpbmdbcHJvdG9Qcm9wXS50cmltIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXJySW5kZXhPZiA9IEFycmF5W3Byb3RvUHJvcF0uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVmVuZG9yczogcGxlYXNlIGFsbG93IGNvbnRlbnQgY29kZSB0byBpbnN0YW50aWF0ZSBET01FeGNlcHRpb25zXG4gICAgICAgICAgLFxuICAgICAgICAgIERPTUV4ID0gZnVuY3Rpb24gKHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IHR5cGU7XG4gICAgICAgICAgICB0aGlzLmNvZGUgPSBET01FeGNlcHRpb25bdHlwZV07XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hlY2tUb2tlbkFuZEdldEluZGV4ID0gZnVuY3Rpb24gKGNsYXNzTGlzdCwgdG9rZW4pIHtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXgoXCJTWU5UQVhfRVJSXCIsIFwiVGhlIHRva2VuIG11c3Qgbm90IGJlIGVtcHR5LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvXFxzLy50ZXN0KHRva2VuKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXgoXCJJTlZBTElEX0NIQVJBQ1RFUl9FUlJcIiwgXCJUaGUgdG9rZW4gbXVzdCBub3QgY29udGFpbiBzcGFjZSBjaGFyYWN0ZXJzLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnJJbmRleE9mLmNhbGwoY2xhc3NMaXN0LCB0b2tlbik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBDbGFzc0xpc3QgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgdmFyIHRyaW1tZWRDbGFzc2VzID0gc3RyVHJpbS5jYWxsKGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiksXG4gICAgICAgICAgICAgIGNsYXNzZXMgPSB0cmltbWVkQ2xhc3NlcyA/IHRyaW1tZWRDbGFzc2VzLnNwbGl0KC9cXHMrLykgOiBbXSxcbiAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgIGxlbiA9IGNsYXNzZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLnB1c2goY2xhc3Nlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbGFzc0xpc3RQcm90byA9IENsYXNzTGlzdFtwcm90b1Byb3BdID0gW10sXG4gICAgICAgICAgY2xhc3NMaXN0R2V0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDbGFzc0xpc3QodGhpcyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgLy8gTW9zdCBET01FeGNlcHRpb24gaW1wbGVtZW50YXRpb25zIGRvbid0IGFsbG93IGNhbGxpbmcgRE9NRXhjZXB0aW9uJ3MgdG9TdHJpbmcoKVxuICAgICAgICAvLyBvbiBub24tRE9NRXhjZXB0aW9ucy4gRXJyb3IncyB0b1N0cmluZygpIGlzIHN1ZmZpY2llbnQgaGVyZS5cbiAgICAgICAgRE9NRXhbcHJvdG9Qcm9wXSA9IEVycm9yW3Byb3RvUHJvcF07XG4gICAgICAgIGNsYXNzTGlzdFByb3RvLml0ZW0gPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiB0aGlzW2ldIHx8IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzTGlzdFByb3RvLmNvbnRhaW5zID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgcmV0dXJuIH5jaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4gKyBcIlwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NMaXN0UHJvdG8uYWRkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0b2tlbnMgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGwgPSB0b2tlbnMubGVuZ3RoLFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV0gKyBcIlwiO1xuICAgICAgICAgICAgaWYgKCF+Y2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKSkge1xuICAgICAgICAgICAgICB0aGlzLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlICgrK2kgPCBsKTtcbiAgICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjbGFzc0xpc3RQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRva2VucyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbCA9IHRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIHVwZGF0ZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGluZGV4O1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcbiAgICAgICAgICAgIGluZGV4ID0gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKTtcbiAgICAgICAgICAgIHdoaWxlICh+aW5kZXgpIHtcbiAgICAgICAgICAgICAgdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaW5kZXggPSBjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKCsraSA8IGwpO1xuICAgICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzTGlzdFByb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uICh0b2tlbiwgZm9yY2UpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jb250YWlucyh0b2tlbiksXG4gICAgICAgICAgICBtZXRob2QgPSByZXN1bHQgPyBmb3JjZSAhPT0gdHJ1ZSAmJiBcInJlbW92ZVwiIDogZm9yY2UgIT09IGZhbHNlICYmIFwiYWRkXCI7XG4gICAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgdGhpc1ttZXRob2RdKHRva2VuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvcmNlID09PSB0cnVlIHx8IGZvcmNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcmNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzTGlzdFByb3RvLnJlcGxhY2UgPSBmdW5jdGlvbiAodG9rZW4sIHJlcGxhY2VtZW50X3Rva2VuKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRva2VuICsgXCJcIik7XG4gICAgICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2UoaW5kZXgsIDEsIHJlcGxhY2VtZW50X3Rva2VuKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NMaXN0UHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuam9pbihcIiBcIik7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvYmpDdHIuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgY2xhc3NMaXN0UHJvcERlc2MgPSB7XG4gICAgICAgICAgICBnZXQ6IGNsYXNzTGlzdEdldHRlcixcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvYmpDdHIuZGVmaW5lUHJvcGVydHkoZWxlbUN0clByb3RvLCBjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RQcm9wRGVzYyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIC8vIElFIDggZG9lc24ndCBzdXBwb3J0IGVudW1lcmFibGU6dHJ1ZVxuICAgICAgICAgICAgLy8gYWRkaW5nIHVuZGVmaW5lZCB0byBmaWdodCB0aGlzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L2NsYXNzTGlzdC5qcy9pc3N1ZXMvMzZcbiAgICAgICAgICAgIC8vIG1vZGVybmllIElFOC1NU1c3IG1hY2hpbmUgaGFzIElFOCA4LjAuNjAwMS4xODcwMiBhbmQgaXMgYWZmZWN0ZWRcbiAgICAgICAgICAgIGlmIChleC5udW1iZXIgPT09IHVuZGVmaW5lZCB8fCBleC5udW1iZXIgPT09IC0weDdGRjVFQzU0KSB7XG4gICAgICAgICAgICAgIGNsYXNzTGlzdFByb3BEZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgb2JqQ3RyLmRlZmluZVByb3BlcnR5KGVsZW1DdHJQcm90bywgY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0UHJvcERlc2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvYmpDdHJbcHJvdG9Qcm9wXS5fX2RlZmluZUdldHRlcl9fKSB7XG4gICAgICAgICAgZWxlbUN0clByb3RvLl9fZGVmaW5lR2V0dGVyX18oY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0R2V0dGVyKTtcbiAgICAgICAgfVxuICAgICAgfSkoc2VsZik7XG4gICAgfVxuXG4gICAgLy8gVGhlcmUgaXMgZnVsbCBvciBwYXJ0aWFsIG5hdGl2ZSBjbGFzc0xpc3Qgc3VwcG9ydCwgc28ganVzdCBjaGVjayBpZiB3ZSBuZWVkXG4gICAgLy8gdG8gbm9ybWFsaXplIHRoZSBhZGQvcmVtb3ZlIGFuZCB0b2dnbGUgQVBJcy5cblxuICAgIChmdW5jdGlvbiAoKSB7XG5cbiAgICAgIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpO1xuICAgICAgdGVzdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImMxXCIsIFwiYzJcIik7XG5cbiAgICAgIC8vIFBvbHlmaWxsIGZvciBJRSAxMC8xMSBhbmQgRmlyZWZveCA8MjYsIHdoZXJlIGNsYXNzTGlzdC5hZGQgYW5kXG4gICAgICAvLyBjbGFzc0xpc3QucmVtb3ZlIGV4aXN0IGJ1dCBzdXBwb3J0IG9ubHkgb25lIGFyZ3VtZW50IGF0IGEgdGltZS5cbiAgICAgIGlmICghdGVzdEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYzJcIikpIHtcbiAgICAgICAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlW21ldGhvZF07XG4gICAgICAgICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICB0b2tlbiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgb3JpZ2luYWwuY2FsbCh0aGlzLCB0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgY3JlYXRlTWV0aG9kKCdhZGQnKTtcbiAgICAgICAgY3JlYXRlTWV0aG9kKCdyZW1vdmUnKTtcbiAgICAgIH1cbiAgICAgIHRlc3RFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJjM1wiLCBmYWxzZSk7XG5cbiAgICAgIC8vIFBvbHlmaWxsIGZvciBJRSAxMCBhbmQgRmlyZWZveCA8MjQsIHdoZXJlIGNsYXNzTGlzdC50b2dnbGUgZG9lcyBub3RcbiAgICAgIC8vIHN1cHBvcnQgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgICAgIGlmICh0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjM1wiKSkge1xuICAgICAgICB2YXIgX3RvZ2dsZSA9IERPTVRva2VuTGlzdC5wcm90b3R5cGUudG9nZ2xlO1xuICAgICAgICBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICh0b2tlbiwgZm9yY2UpIHtcbiAgICAgICAgICBpZiAoMSBpbiBhcmd1bWVudHMgJiYgIXRoaXMuY29udGFpbnModG9rZW4pID09PSAhZm9yY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JjZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF90b2dnbGUuY2FsbCh0aGlzLCB0b2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyByZXBsYWNlKCkgcG9seWZpbGxcbiAgICAgIGlmICghKFwicmVwbGFjZVwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpLmNsYXNzTGlzdCkpIHtcbiAgICAgICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHRva2VuLCByZXBsYWNlbWVudF90b2tlbikge1xuICAgICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLnRvU3RyaW5nKCkuc3BsaXQoXCIgXCIpLFxuICAgICAgICAgICAgaW5kZXggPSB0b2tlbnMuaW5kZXhPZih0b2tlbiArIFwiXCIpO1xuICAgICAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5zbGljZShpbmRleCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZS5hcHBseSh0aGlzLCB0b2tlbnMpO1xuICAgICAgICAgICAgdGhpcy5hZGQocmVwbGFjZW1lbnRfdG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5hZGQuYXBwbHkodGhpcywgdG9rZW5zLnNsaWNlKDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0ZXN0RWxlbWVudCA9IG51bGw7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YXlsb3JoYWtlcy9wcm9taXNlLXBvbHlmaWxsXG5cbiAgKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KCkgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOiBmYWN0b3J5KCk7XG4gIH0pKHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXHJcbiAgICAqIEB0aGlzIHtQcm9taXNlfVxyXG4gICAgKi9cbiAgICBmdW5jdGlvbiBmaW5hbGx5Q29uc3RydWN0b3IoY2FsbGJhY2spIHtcbiAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWxsU2V0dGxlZChhcnIpIHtcbiAgICAgIHZhciBQID0gdGhpcztcbiAgICAgIHJldHVybiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmICghKGFyciAmJiB0eXBlb2YgYXJyLmxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKHR5cGVvZiBhcnIgKyAnICcgKyBhcnIgKyAnIGlzIG5vdCBpdGVyYWJsZShjYW5ub3QgcmVhZCBwcm9wZXJ0eSBTeW1ib2woU3ltYm9sLml0ZXJhdG9yKSknKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBmdW5jdGlvbiByZXMoaSwgdmFsKSB7XG4gICAgICAgICAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHZhciB0aGVuID0gdmFsLnRoZW47XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdGhlbi5jYWxsKHZhbCwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSB7XG4gICAgICAgICAgICAgICAgICBzdGF0dXM6ICdyZWplY3RlZCcsXG4gICAgICAgICAgICAgICAgICByZWFzb246IGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGFyZ3NbaV0gPSB7XG4gICAgICAgICAgICBzdGF0dXM6ICdmdWxmaWxsZWQnLFxuICAgICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZXMoaSwgYXJnc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIHByb21pc2UtcG9seWZpbGwgd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gICAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG4gICAgdmFyIHNldFRpbWVvdXRGdW5jID0gc2V0VGltZW91dDtcbiAgICBmdW5jdGlvbiBpc0FycmF5KHgpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKHggJiYgdHlwZW9mIHgubGVuZ3RoICE9PSAndW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4gICAgLy8gUG9seWZpbGwgZm9yIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gICAgZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gICAgKi9cbiAgICBmdW5jdGlvbiBQcm9taXNlKGZuKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgIC8qKiBAdHlwZSB7IW51bWJlcn0gKi9cbiAgICAgIHRoaXMuX3N0YXRlID0gMDtcbiAgICAgIC8qKiBAdHlwZSB7IWJvb2xlYW59ICovXG4gICAgICB0aGlzLl9oYW5kbGVkID0gZmFsc2U7XG4gICAgICAvKiogQHR5cGUge1Byb21pc2V8dW5kZWZpbmVkfSAqL1xuICAgICAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAvKiogQHR5cGUgeyFBcnJheTwhRnVuY3Rpb24+fSAqL1xuICAgICAgdGhpcy5fZGVmZXJyZWRzID0gW107XG4gICAgICBkb1Jlc29sdmUoZm4sIHRoaXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGUoc2VsZiwgZGVmZXJyZWQpIHtcbiAgICAgIHdoaWxlIChzZWxmLl9zdGF0ZSA9PT0gMykge1xuICAgICAgICBzZWxmID0gc2VsZi5fdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5fc3RhdGUgPT09IDApIHtcbiAgICAgICAgc2VsZi5fZGVmZXJyZWRzLnB1c2goZGVmZXJyZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWxmLl9oYW5kbGVkID0gdHJ1ZTtcbiAgICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNiID0gc2VsZi5fc3RhdGUgPT09IDEgPyBkZWZlcnJlZC5vbkZ1bGZpbGxlZCA6IGRlZmVycmVkLm9uUmVqZWN0ZWQ7XG4gICAgICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgICAgIChzZWxmLl9zdGF0ZSA9PT0gMSA/IHJlc29sdmUgOiByZWplY3QpKGRlZmVycmVkLnByb21pc2UsIHNlbGYuX3ZhbHVlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXQgPSBjYihzZWxmLl92YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZGVmZXJyZWQucHJvbWlzZSwgZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoZGVmZXJyZWQucHJvbWlzZSwgcmV0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlKHNlbGYsIG5ld1ZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlOiBodHRwczovL2dpdGh1Yi5jb20vcHJvbWlzZXMtYXBsdXMvcHJvbWlzZXMtc3BlYyN0aGUtcHJvbWlzZS1yZXNvbHV0aW9uLXByb2NlZHVyZVxuICAgICAgICBpZiAobmV3VmFsdWUgPT09IHNlbGYpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJyk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAmJiAodHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgdmFyIHRoZW4gPSBuZXdWYWx1ZS50aGVuO1xuICAgICAgICAgIGlmIChuZXdWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHNlbGYuX3N0YXRlID0gMztcbiAgICAgICAgICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICBmaW5hbGUoc2VsZik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZG9SZXNvbHZlKGJpbmQodGhlbiwgbmV3VmFsdWUpLCBzZWxmKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5fc3RhdGUgPSAxO1xuICAgICAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICBmaW5hbGUoc2VsZik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChzZWxmLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVqZWN0KHNlbGYsIG5ld1ZhbHVlKSB7XG4gICAgICBzZWxmLl9zdGF0ZSA9IDI7XG4gICAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgZmluYWxlKHNlbGYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5hbGUoc2VsZikge1xuICAgICAgaWYgKHNlbGYuX3N0YXRlID09PSAyICYmIHNlbGYuX2RlZmVycmVkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgUHJvbWlzZS5faW1tZWRpYXRlRm4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghc2VsZi5faGFuZGxlZCkge1xuICAgICAgICAgICAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4oc2VsZi5fdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZi5fZGVmZXJyZWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGhhbmRsZShzZWxmLCBzZWxmLl9kZWZlcnJlZHNbaV0pO1xuICAgICAgfVxuICAgICAgc2VsZi5fZGVmZXJyZWRzID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcclxuICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAqL1xuICAgIGZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb21pc2UpIHtcbiAgICAgIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGw7XG4gICAgICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICAgICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB9XG5cbiAgICAvKipcclxuICAgICogVGFrZSBhIHBvdGVudGlhbGx5IG1pc2JlaGF2aW5nIHJlc29sdmVyIGZ1bmN0aW9uIGFuZCBtYWtlIHN1cmVcclxuICAgICogb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgYXJlIG9ubHkgY2FsbGVkIG9uY2UuXHJcbiAgICAqXHJcbiAgICAqIE1ha2VzIG5vIGd1YXJhbnRlZXMgYWJvdXQgYXN5bmNocm9ueS5cclxuICAgICovXG4gICAgZnVuY3Rpb24gZG9SZXNvbHZlKGZuLCBzZWxmKSB7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICByZXNvbHZlKHNlbGYsIHZhbHVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgcmVqZWN0KHNlbGYsIHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlamVjdChzZWxmLCBleCk7XG4gICAgICB9XG4gICAgfVxuICAgIFByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gICAgfTtcbiAgICBQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB2YXIgcHJvbSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG5vb3ApO1xuICAgICAgaGFuZGxlKHRoaXMsIG5ldyBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBwcm9tKSk7XG4gICAgICByZXR1cm4gcHJvbTtcbiAgICB9O1xuICAgIFByb21pc2UucHJvdG90eXBlWydmaW5hbGx5J10gPSBmaW5hbGx5Q29uc3RydWN0b3I7XG4gICAgUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAoIWlzQXJyYXkoYXJyKSkge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignUHJvbWlzZS5hbGwgYWNjZXB0cyBhbiBhcnJheScpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycik7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGZ1bmN0aW9uIHJlcyhpLCB2YWwpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgdmFyIHRoZW4gPSB2YWwudGhlbjtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhlbi5jYWxsKHZhbCwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgcmVzKGksIHZhbCk7XG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3NbaV0gPSB2YWw7XG4gICAgICAgICAgICBpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcmVzKGksIGFyZ3NbaV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIFByb21pc2UuYWxsU2V0dGxlZCA9IGFsbFNldHRsZWQ7XG4gICAgUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIFByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZWplY3QodmFsdWUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBQcm9taXNlLnJhY2UgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAoIWlzQXJyYXkoYXJyKSkge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignUHJvbWlzZS5yYWNlIGFjY2VwdHMgYW4gYXJyYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZShhcnJbaV0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFVzZSBwb2x5ZmlsbCBmb3Igc2V0SW1tZWRpYXRlIGZvciBwZXJmb3JtYW5jZSBnYWluc1xuICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuID1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgfSB8fCBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHNldFRpbWVvdXRGdW5jKGZuLCAwKTtcbiAgICB9O1xuICAgIFByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbkZuID0gZnVuY3Rpb24gX3VuaGFuZGxlZFJlamVjdGlvbkZuKGVycikge1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUG9zc2libGUgVW5oYW5kbGVkIFByb21pc2UgUmVqZWN0aW9uOicsIGVycik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKiogQHN1cHByZXNzIHt1bmRlZmluZWRWYXJzfSAqL1xuICAgIHZhciBnbG9iYWxOUyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHRoZSBvbmx5IHJlbGlhYmxlIG1lYW5zIHRvIGdldCB0aGUgZ2xvYmFsIG9iamVjdCBpc1xuICAgICAgLy8gYEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClgXG4gICAgICAvLyBIb3dldmVyLCB0aGlzIGNhdXNlcyBDU1AgdmlvbGF0aW9ucyBpbiBDaHJvbWUgYXBwcy5cbiAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QnKTtcbiAgICB9KCk7XG5cbiAgICAvLyBFeHBvc2UgdGhlIHBvbHlmaWxsIGlmIFByb21pc2UgaXMgdW5kZWZpbmVkIG9yIHNldCB0byBhXG4gICAgLy8gbm9uLWZ1bmN0aW9uIHZhbHVlLiBUaGUgbGF0dGVyIGNhbiBiZSBkdWUgdG8gYSBuYW1lZCBIVE1MRWxlbWVudFxuICAgIC8vIGJlaW5nIGV4cG9zZWQgYnkgYnJvd3NlcnMgZm9yIGxlZ2FjeSByZWFzb25zLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YXlsb3JoYWtlcy9wcm9taXNlLXBvbHlmaWxsL2lzc3Vlcy8xMTRcbiAgICBpZiAodHlwZW9mIGdsb2JhbE5TWydQcm9taXNlJ10gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGdsb2JhbE5TWydQcm9taXNlJ10gPSBQcm9taXNlO1xuICAgIH0gZWxzZSBpZiAoIWdsb2JhbE5TLlByb21pc2UucHJvdG90eXBlWydmaW5hbGx5J10pIHtcbiAgICAgIGdsb2JhbE5TLlByb21pc2UucHJvdG90eXBlWydmaW5hbGx5J10gPSBmaW5hbGx5Q29uc3RydWN0b3I7XG4gICAgfSBlbHNlIGlmICghZ2xvYmFsTlMuUHJvbWlzZS5hbGxTZXR0bGVkKSB7XG4gICAgICBnbG9iYWxOUy5Qcm9taXNlLmFsbFNldHRsZWQgPSBhbGxTZXR0bGVkO1xuICAgIH1cbiAgfSk7XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@yaireo/tagify/dist/tagify.polyfills.min.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./node_modules/@yaireo/tagify/dist/tagify.polyfills.min.js");
/******/ 	
/******/ })()
;